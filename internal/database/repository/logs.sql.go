// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: logs.sql

package repository

import (
	"context"
	"database/sql"
)

const logsCreate = `-- name: LogsCreate :one
INSERT INTO logs (
    request_id,
    remote_ip,
    host,
    method,
    uri,
    user_agent,
    status,
    error,
    latency,
    latency_human,
    bytes_in,
    bytes_out
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12
) RETURNING id, timestamp, request_id, remote_ip, host, method, uri, user_agent, status, error, latency, latency_human, bytes_in, bytes_out
`

type LogsCreateParams struct {
	RequestID    sql.NullString `json:"request_id"`
	RemoteIp     sql.NullString `json:"remote_ip"`
	Host         sql.NullString `json:"host"`
	Method       sql.NullString `json:"method"`
	Uri          sql.NullString `json:"uri"`
	UserAgent    sql.NullString `json:"user_agent"`
	Status       sql.NullInt64  `json:"status"`
	Error        sql.NullString `json:"error"`
	Latency      sql.NullInt64  `json:"latency"`
	LatencyHuman sql.NullString `json:"latency_human"`
	BytesIn      sql.NullInt64  `json:"bytes_in"`
	BytesOut     sql.NullInt64  `json:"bytes_out"`
}

func (q *Queries) LogsCreate(ctx context.Context, arg LogsCreateParams) (Log, error) {
	row := q.db.QueryRowContext(ctx, logsCreate,
		arg.RequestID,
		arg.RemoteIp,
		arg.Host,
		arg.Method,
		arg.Uri,
		arg.UserAgent,
		arg.Status,
		arg.Error,
		arg.Latency,
		arg.LatencyHuman,
		arg.BytesIn,
		arg.BytesOut,
	)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.RequestID,
		&i.RemoteIp,
		&i.Host,
		&i.Method,
		&i.Uri,
		&i.UserAgent,
		&i.Status,
		&i.Error,
		&i.Latency,
		&i.LatencyHuman,
		&i.BytesIn,
		&i.BytesOut,
	)
	return i, err
}

const logsGetAll = `-- name: LogsGetAll :many
SELECT method, status as response, uri as path, latency_human as response_time, timestamp as created_at
FROM logs
ORDER BY timestamp DESC
`

type LogsGetAllRow struct {
	Method       sql.NullString `json:"method"`
	Response     sql.NullInt64  `json:"response"`
	Path         sql.NullString `json:"path"`
	ResponseTime sql.NullString `json:"response_time"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) LogsGetAll(ctx context.Context) ([]LogsGetAllRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetAllRow{}
	for rows.Next() {
		var i LogsGetAllRow
		if err := rows.Scan(
			&i.Method,
			&i.Response,
			&i.Path,
			&i.ResponseTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetBasicView = `-- name: LogsGetBasicView :many
SELECT method, status as response, uri as path, latency_human as response_time, timestamp as created_at
FROM logs
ORDER BY timestamp DESC
`

type LogsGetBasicViewRow struct {
	Method       sql.NullString `json:"method"`
	Response     sql.NullInt64  `json:"response"`
	Path         sql.NullString `json:"path"`
	ResponseTime sql.NullString `json:"response_time"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) LogsGetBasicView(ctx context.Context) ([]LogsGetBasicViewRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetBasicView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetBasicViewRow{}
	for rows.Next() {
		var i LogsGetBasicViewRow
		if err := rows.Scan(
			&i.Method,
			&i.Response,
			&i.Path,
			&i.ResponseTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetBasicViewWithOffsetLimit = `-- name: LogsGetBasicViewWithOffsetLimit :many
SELECT method, status as response, uri as path, latency_human as response_time, timestamp as created_at
FROM logs
ORDER BY timestamp DESC
LIMIT ?2 OFFSET ?1
`

type LogsGetBasicViewWithOffsetLimitParams struct {
	Limit    int64 `json:"limit"`
	Begining int64 `json:"begining"`
}

type LogsGetBasicViewWithOffsetLimitRow struct {
	Method       sql.NullString `json:"method"`
	Response     sql.NullInt64  `json:"response"`
	Path         sql.NullString `json:"path"`
	ResponseTime sql.NullString `json:"response_time"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) LogsGetBasicViewWithOffsetLimit(ctx context.Context, arg LogsGetBasicViewWithOffsetLimitParams) ([]LogsGetBasicViewWithOffsetLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetBasicViewWithOffsetLimit, arg.Limit, arg.Begining)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetBasicViewWithOffsetLimitRow{}
	for rows.Next() {
		var i LogsGetBasicViewWithOffsetLimitRow
		if err := rows.Scan(
			&i.Method,
			&i.Response,
			&i.Path,
			&i.ResponseTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetBasicViewWithOffsetLimitAdvanced = `-- name: LogsGetBasicViewWithOffsetLimitAdvanced :many
SELECT 
    method,
    status AS response,
    uri AS path,
    latency_human AS response_time,
    timestamp AS created_at
FROM logs
WHERE timestamp >= datetime('now', ?1)
  AND (
        ?2 IS NULL 
        OR ?2 = '' 
        OR method = ?2
      )
  AND (
        ?3 IS NULL 
        OR ?3 = '' 
        OR status = ?3
      )
ORDER BY timestamp DESC
LIMIT ?5 OFFSET ?4
`

type LogsGetBasicViewWithOffsetLimitAdvancedParams struct {
	Timerange    interface{} `json:"timerange"`
	Method       interface{} `json:"method"`
	Responsetype interface{} `json:"responsetype"`
	Limit        int64       `json:"limit"`
	Begining     int64       `json:"begining"`
}

type LogsGetBasicViewWithOffsetLimitAdvancedRow struct {
	Method       sql.NullString `json:"method"`
	Response     sql.NullInt64  `json:"response"`
	Path         sql.NullString `json:"path"`
	ResponseTime sql.NullString `json:"response_time"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) LogsGetBasicViewWithOffsetLimitAdvanced(ctx context.Context, arg LogsGetBasicViewWithOffsetLimitAdvancedParams) ([]LogsGetBasicViewWithOffsetLimitAdvancedRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetBasicViewWithOffsetLimitAdvanced,
		arg.Timerange,
		arg.Method,
		arg.Responsetype,
		arg.Limit,
		arg.Begining,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetBasicViewWithOffsetLimitAdvancedRow{}
	for rows.Next() {
		var i LogsGetBasicViewWithOffsetLimitAdvancedRow
		if err := rows.Scan(
			&i.Method,
			&i.Response,
			&i.Path,
			&i.ResponseTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetBasicViewWithOffsetLimitAdvancedOld = `-- name: LogsGetBasicViewWithOffsetLimitAdvancedOld :many
SELECT method, status as response, uri as path, latency_human as response_time, timestamp as created_at
FROM logs
WHERE timestamp >= datetime('now', ?1)
    AND method = ?2
    AND status = ?3
ORDER BY timestamp DESC
LIMIT ?5 OFFSET ?4
`

type LogsGetBasicViewWithOffsetLimitAdvancedOldParams struct {
	Timerange    interface{}    `json:"timerange"`
	Method       sql.NullString `json:"method"`
	Responsetype sql.NullInt64  `json:"responsetype"`
	Limit        int64          `json:"limit"`
	Begining     int64          `json:"begining"`
}

type LogsGetBasicViewWithOffsetLimitAdvancedOldRow struct {
	Method       sql.NullString `json:"method"`
	Response     sql.NullInt64  `json:"response"`
	Path         sql.NullString `json:"path"`
	ResponseTime sql.NullString `json:"response_time"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) LogsGetBasicViewWithOffsetLimitAdvancedOld(ctx context.Context, arg LogsGetBasicViewWithOffsetLimitAdvancedOldParams) ([]LogsGetBasicViewWithOffsetLimitAdvancedOldRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetBasicViewWithOffsetLimitAdvancedOld,
		arg.Timerange,
		arg.Method,
		arg.Responsetype,
		arg.Limit,
		arg.Begining,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetBasicViewWithOffsetLimitAdvancedOldRow{}
	for rows.Next() {
		var i LogsGetBasicViewWithOffsetLimitAdvancedOldRow
		if err := rows.Scan(
			&i.Method,
			&i.Response,
			&i.Path,
			&i.ResponseTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetMethodStats = `-- name: LogsGetMethodStats :many
SELECT 
    method,
    COUNT(*) as count,
    AVG(latency) as avg_response_time,
    MIN(latency) as min_response_time,
    MAX(latency) as max_response_time
FROM logs
GROUP BY method
ORDER BY count DESC
`

type LogsGetMethodStatsRow struct {
	Method          sql.NullString  `json:"method"`
	Count           int64           `json:"count"`
	AvgResponseTime sql.NullFloat64 `json:"avg_response_time"`
	MinResponseTime interface{}     `json:"min_response_time"`
	MaxResponseTime interface{}     `json:"max_response_time"`
}

func (q *Queries) LogsGetMethodStats(ctx context.Context) ([]LogsGetMethodStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetMethodStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetMethodStatsRow{}
	for rows.Next() {
		var i LogsGetMethodStatsRow
		if err := rows.Scan(
			&i.Method,
			&i.Count,
			&i.AvgResponseTime,
			&i.MinResponseTime,
			&i.MaxResponseTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetStatusStats = `-- name: LogsGetStatusStats :many
SELECT 
    status as response,
    COUNT(*) as count,
    AVG(latency) as avg_response_time
FROM logs
GROUP BY status
ORDER BY count DESC
`

type LogsGetStatusStatsRow struct {
	Response        sql.NullInt64   `json:"response"`
	Count           int64           `json:"count"`
	AvgResponseTime sql.NullFloat64 `json:"avg_response_time"`
}

func (q *Queries) LogsGetStatusStats(ctx context.Context) ([]LogsGetStatusStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, logsGetStatusStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogsGetStatusStatsRow{}
	for rows.Next() {
		var i LogsGetStatusStatsRow
		if err := rows.Scan(&i.Response, &i.Count, &i.AvgResponseTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logsGetUniqueMethods = `-- name: LogsGetUniqueMethods :many
SELECT DISTINCT method
FROM logs
ORDER BY method ASC
`

func (q *Queries) LogsGetUniqueMethods(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, logsGetUniqueMethods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var method sql.NullString
		if err := rows.Scan(&method); err != nil {
			return nil, err
		}
		items = append(items, method)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
